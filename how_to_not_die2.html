<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>How To Not Die — Rooftop Prototype</title>
<style>
  :root{
    --bg:#000;
    --fg:#fff;
    --muted:#9a9a9a;
  }
  html,body{height:100%; margin:0; background:var(--bg); color:var(--fg); font-family: "Courier New", monospace; overflow:hidden;}
  canvas{display:block; background: linear-gradient(#050505,#121212);}
  #ui{position:absolute; left:0; right:0; top:8px; display:flex; justify-content:space-between; padding:0 16px; pointer-events:none; font-size:13px; color:var(--muted);}
  #message{position:absolute; left:50%; transform:translateX(-50%); bottom:12%; width:84%; text-align:center; font-size:1.05rem; color:var(--fg); opacity:0; transition:opacity .35s; pointer-events:none;}
  #hint{position:absolute; left:50%; transform:translateX(-50%); bottom:4%; color:var(--muted); font-size:12px; pointer-events:none;}
  .mini{font-size:12px; color:var(--muted);}
  
  /* Minimap */
  #minimap{
    position:absolute;
    top:40px;
    right:16px;
    width:200px;
    height:60px;
    background:rgba(0,0,0,0.7);
    border:1px solid rgba(255,255,255,0.2);
    pointer-events:none;
  }
  
  /* Death overlay (red blood fade) */
  #deathOverlay{
    position:absolute;
    top:0;
    left:0;
    width:100%;
    height:100%;
    background: radial-gradient(circle, rgba(139,0,0,0) 0%, rgba(139,0,0,0.4) 40%, rgba(80,0,0,0.8) 100%);
    opacity:0;
    transition: opacity 0.8s ease-out;
    pointer-events:none;
    z-index:10;
  }
  
  #deathOverlay.active{
    opacity:1;
  }
  
  /* Retry button */
  #retryBtn{
    position:absolute;
    left:50%;
    top:50%;
    transform:translate(-50%, -50%);
    padding:14px 32px;
    background:rgba(139,0,0,0.85);
    border:2px solid rgba(255,255,255,0.4);
    color:#fff;
    font-family: "Courier New", monospace;
    font-size:16px;
    cursor:pointer;
    opacity:0;
    pointer-events:none;
    transition: opacity 0.4s ease-in 0.6s, background 0.2s;
    z-index:11;
  }
  
  #retryBtn.show{
    opacity:1;
    pointer-events:auto;
  }
  
  #retryBtn:hover{
    background:rgba(180,0,0,0.95);
    border-color:rgba(255,255,255,0.7);
  }
  
  @media (max-width:600px){
    #hint{font-size:11px;}
    #minimap{width:150px; height:45px; top:35px; right:10px;}
    #retryBtn{font-size:14px; padding:12px 24px;}
  }
</style>
</head>
<body>
<canvas id="c"></canvas>
<canvas id="minimap"></canvas>
<div id="ui">
  <div class="mini">Fragments: <span id="fragCount">0</span>/<span id="fragTotal">0</span></div>
  <div class="mini">Light: <span id="lightVal">0</span></div>
  <div class="mini">Distance: <span id="distVal">0</span>m</div>
</div>
<div id="message"></div>
<div id="hint">Click & drag: draw bridge between rooftops · Bridges last briefly · Goal: keep him walking</div>
<div id="deathOverlay"></div>
<button id="retryBtn">Try Again</button>

<script>
/* ------------------------------------------------------------------
   How To Not Die — Full Prototype (autorun + draw-bridges + fragments)
   ------------------------------------------------------------------ */

const canvas = document.getElementById('c');
const ctx = canvas.getContext('2d');
let W = canvas.width = window.innerWidth;
let H = canvas.height = window.innerHeight;
window.addEventListener('resize', ()=>{ W = canvas.width = window.innerWidth; H = canvas.height = window.innerHeight; regenParallax(); initMinimap(); });

// Minimap setup
const minimapCanvas = document.getElementById('minimap');
const minimapCtx = minimapCanvas.getContext('2d');
let MINIMAP_W = 200;
let MINIMAP_H = 60;

function initMinimap(){
  const rect = minimapCanvas.getBoundingClientRect();
  MINIMAP_W = rect.width;
  MINIMAP_H = rect.height;
  minimapCanvas.width = MINIMAP_W;
  minimapCanvas.height = MINIMAP_H;
}
initMinimap();

const ui = {
  fragCount: document.getElementById('fragCount'),
  fragTotal: document.getElementById('fragTotal'),
  lightVal: document.getElementById('lightVal'),
  distVal: document.getElementById('distVal'),
  message: document.getElementById('message'),
  deathOverlay: document.getElementById('deathOverlay'),
  retryBtn: document.getElementById('retryBtn')
};

// Retry button handler
ui.retryBtn.addEventListener('click', ()=> {
  resetToStart();
});

/* ---------- World / generation ---------- */
const WORLD_WIDTH = 4200;
const buildings = []; // {x, w, h, topY}
function generateBuildings(){
  buildings.length = 0;
  let x = 0;
  
  // FIRST BUILDING: Always stable, predictable starting platform
  const firstW = 240;
  const firstH = 180;
  const firstTopY = H - 60 - firstH;
  buildings.push({x: 0, w: firstW, h: firstH, topY: firstTopY});
  x = firstW + 120; // gap after first building
  
  // Rest of buildings: random
  while (x < WORLD_WIDTH - 80) {
    const w = 160 + Math.round(Math.random()*220);
    const h = 120 + Math.round(Math.random()*300);
    const topY = H - 60 - h;
    buildings.push({x, w, h, topY});
    // spacing (gap) random
    x += w + (60 + Math.round(Math.random()*220));
  }
}
generateBuildings();

/* ---------- Fragments (collectibles) ---------- */
const fragmentTexts = [
  "You used to laugh easier.",
  "There was a name you missed calling once.",
  "Living took practice.",
  "You still have fingerprints on the window.",
  "The sky forgives, quietly."
];
const fragments = [];
function placeFragments(){
  fragments.length = 0;
  // place fragments on some rooftop positions (SKIP first building)
  const eligibleBuildings = buildings.slice(1); // skip index 0
  for (let i=0;i<fragmentTexts.length;i++){
    const b = eligibleBuildings[ Math.floor( Math.random() * eligibleBuildings.length ) ];
    const fx = b.x + 20 + Math.random()*(b.w-40);
    const fy = b.topY - 6;
    fragments.push({x:fx,y:fy,text:fragmentTexts[i],taken:false,size:10+Math.random()*6});
  }
}
placeFragments();
ui.fragTotal.textContent = fragments.length;

/* ---------- Player (auto-run) ---------- */
const player = {
  x: 120, // FIXED starting position
  y: 0,
  w: 26,
  h: 34,
  vx: 1.8,
  speed: 1.8,
  vy: 0,
  onGround: false
};

// Initialize player position properly on first building
function initPlayerPosition(){
  if (buildings.length > 0) {
    const firstBuilding = buildings[0];
    player.x = firstBuilding.x + firstBuilding.w / 2; // center of first building
    player.y = firstBuilding.topY - player.h / 2 - 2; // on top
    player.vy = 0;
    player.onGround = true; // IMPORTANT: mark as grounded
  }
}

initPlayerPosition(); // Call after generateBuildings()

/* ---------- Camera ---------- */
let camX = 0;

/* ---------- Bridges (drawn by player) ---------- */
const bridges = []; // {x1,y1,x2,y2,life,maxLife}
const BRIDGE_MAX_DURATION = 2200; // ms
const BRIDGE_MAX_DIST = 900; // max drawing length allowed

/* ---------- Input (mouse draw) ---------- */
let isDrawing = false;
let drawStart = null;
let drawEnd = null;
canvas.addEventListener('mousedown', (e)=> {
  const mx = e.clientX + camX;
  const my = e.clientY;
  isDrawing = true;
  drawStart = {x: mx, y: my};
});
canvas.addEventListener('mousemove', (e)=> {
  if (!isDrawing) return;
  drawEnd = {x: e.clientX + camX, y: e.clientY};
});
window.addEventListener('mouseup', (e)=> {
  if (!isDrawing) return;
  isDrawing = false;
  const mx = e.clientX + camX;
  const my = e.clientY;
  drawEnd = {x: mx, y: my};
  attemptCreateBridge(drawStart, drawEnd);
  drawStart = drawEnd = null;
});

/* ---------- Trail (echo) ---------- */
const trail = []; // {x,y,life}
const TRAIL_MAX = 200;

/* ---------- Light system ---------- */
let light = 0.5; // 0..1
const LIGHT_MIN = 0.05;
const LIGHT_MAX = 1.0;
const LIGHT_DECAY = 0.0006; // per ms gradually decays
const LIGHT_PICKUP = 0.24;

/* ---------- Void messages ---------- */
const voidMessages = [
  "You think drawing will fix it?",
  "Lines are temporary. So are you, maybe.",
  "Silence listens from below.",
  "Someone draws, someone walks, someone forgets."
];
let lastVoidAt = -Infinity;
const VOID_INTERVAL = 6000;

/* ---------- Ending / reset ---------- */
let endingTriggered = false;
let fade = 0;
let isDead = false; // NEW: track death state

/* ---------- Parallax shapes ---------- */
let parallaxShapes = [];
function regenParallax(){
  parallaxShapes = [];
  for (let i=0;i<18;i++){
    parallaxShapes.push({
      x: Math.random()*WORLD_WIDTH,
      w: 8 + Math.random()*30,
      h: 80 + Math.random()*200,
      yOffset: Math.random()*120
    });
  }
}
regenParallax();

/* ---------- Utilities ---------- */
function clamp(v,a,b){ return Math.max(a, Math.min(b, v)); }
function nowMs(){ return performance.now(); }
function dist(a,b,c,d){ const dx=a-c, dy=b-d; return Math.sqrt(dx*dx+dy*dy); }

/* ---------- Bridge creation logic ---------- */
function rooftopAt(x){
  // return building object if x is over a building top
  for (let b of buildings){
    if (x >= b.x && x <= b.x + b.w) return b;
  }
  return null;
}
function attemptCreateBridge(s,e){
  // require both endpoints to be on rooftop tops (within small vertical tolerance)
  const r1 = rooftopAt(s.x);
  const r2 = rooftopAt(e.x);
  if (!r1 || !r2) {
    showMessage("Bridges must connect rooftops.", 1400);
    return;
  }
  // FIXED: Use exact building topY instead of mouse Y
  const y1 = r1.topY;
  const y2 = r2.topY;
  const distance = Math.abs(s.x - e.x);
  if (distance > BRIDGE_MAX_DIST) {
    showMessage("The gap is too wide.", 1300);
    return;
  }
  // FIXED: Snap X coordinates to building edges if needed
  const x1 = clamp(s.x, r1.x, r1.x + r1.w);
  const x2 = clamp(e.x, r2.x, r2.x + r2.w);
  
  // create bridge with proper coordinates
  const b = {x1: x1, y1: y1, x2: x2, y2: y2, life: BRIDGE_MAX_DURATION, maxLife: BRIDGE_MAX_DURATION};
  bridges.push(b);
  // small light bonus for making bridge (metaphor: effort)
  light = clamp(light + 0.02, LIGHT_MIN, LIGHT_MAX);
}

/* ---------- Physics & collision ---------- */
const GRAV = 0.35;
function pointOnBridge(px, py, bridge){
  // Check if player X is within bridge X range first
  const minX = Math.min(bridge.x1, bridge.x2);
  const maxX = Math.max(bridge.x1, bridge.x2);
  
  if (px < minX - 15 || px > maxX + 15) return false; // not in horizontal range
  
  // treat bridge as line segment with thickness
  const ax = bridge.x1, ay = bridge.y1;
  const bx = bridge.x2, by = bridge.y2;
  const vx = bx - ax, vy = by - ay;
  const wx = px - ax, wy = py - ay;
  const c1 = (wx*vx + wy*vy);
  const c2 = (vx*vx + vy*vy);
  const t = c2 === 0 ? 0 : clamp(c1 / c2, 0, 1);
  // closest point:
  const cx = ax + vx * t, cy = ay + vy * t;
  const d = Math.hypot(px - cx, py - cy);
  
  // Check if player is ABOVE or very close to bridge vertically
  const verticalDiff = py - cy;
  
  // Allow collision if:
  // 1. Player is within distance threshold AND
  // 2. Player is above the bridge line (or slightly below for climbing)
  return d < 25 && verticalDiff > -20 && verticalDiff < 30;
}

/* ---------- Collect fragment ---------- */
function collectFragment(f){
  if (f.taken) return;
  f.taken = true;
  light = clamp(light + LIGHT_PICKUP, LIGHT_MIN, LIGHT_MAX);
  showMessage(f.text, 3200);
  // burst trail
  for (let i=0;i<12;i++) trail.push({x: f.x + (Math.random()*40-20), y: f.y, life: 100 + Math.random()*100});
}

/* ---------- Reset to start (gentle) ---------- */
function resetToStart(reasonTxt){
  // Show death overlay and retry button
  isDead = true;
  ui.deathOverlay.classList.add('active');
  
  if (reasonTxt) {
    showMessage(reasonTxt, 0); // Keep message visible
  }
  
  // Show retry button after overlay animation
  setTimeout(()=> {
    ui.retryBtn.classList.add('show');
  }, 800);
}

// Actual reset function (called by retry button)
function doReset(){
  // Hide death UI
  ui.deathOverlay.classList.remove('active');
  ui.retryBtn.classList.remove('show');
  ui.message.style.opacity = 0;
  isDead = false;
  
  // Reset state
  player.vy = 0;
  player.speed = 1.8;
  camX = 0;
  trail.length = 0;
  bridges.length = 0;
  for (let f of fragments) f.taken = false;
  ui.fragCount.textContent = 0;
  light = 0.45;
  endingTriggered = false;
  fade = 0;
  
  // Regenerate world (shuffle/randomize)
  generateBuildings();
  placeFragments();
  regenParallax();
  initPlayerPosition();
  
  // Show tutorial message
  showMessage("He runs. You draw bridges between rooftops. Keep him walking.", 4600);
}

// Update retry button to call doReset
ui.retryBtn.removeEventListener('click', resetToStart);
ui.retryBtn.addEventListener('click', doReset);

/* ---------- Message helper ---------- */
let messageTimeout = null;
function showMessage(txt, ms=2200){
  ui.message.style.opacity = 1;
  ui.message.textContent = txt;
  if (messageTimeout) clearTimeout(messageTimeout);
  if (ms>0) messageTimeout = setTimeout(()=>{ ui.message.style.opacity = 0; messageTimeout = null; }, ms);
}

/* ---------- Main loop ---------- */
let last = performance.now();
function loop(t){
  const dt = t - last;
  last = t;
  if (!isDead) update(dt); // Only update if not dead
  render();
  requestAnimationFrame(loop);
}
requestAnimationFrame(loop);

/* ---------- Update ---------- */
function update(dt){
  if (endingTriggered){
    fade = clamp(fade + dt/2200, 0, 1);
    return;
  }

  // auto-run speed ramp slight over distance
  player.speed = 1.8 + (player.x / WORLD_WIDTH) * 1.6;
  player.vx = player.speed;

  // horizontal progress
  player.x += player.vx;

  // gravity & vertical movement
  player.vy += GRAV;
  player.y += player.vy;

  // Detect fall EARLY
  const isFalling = player.y - player.h/2 > H + 80;
  
  // camera center - ONLY UPDATE IF NOT FALLING
  if (!isFalling) {
    camX = clamp(player.x - W/2 + player.w/2, 0, WORLD_WIDTH - W);
  }

  // Trail echo when moving fast
  if (Math.random() < 0.5) trail.push({x: player.x, y: player.y + player.h/2, life: 140});
  if (trail.length > TRAIL_MAX) trail.shift();
  for (let t of trail) t.life -= dt * 0.18;
  while (trail.length && trail[0].life <= 0) trail.shift();

  // Decrease bridge life
  for (let i=bridges.length-1;i>=0;i--){
    bridges[i].life -= dt;
    if (bridges[i].life <= 0) bridges.splice(i,1);
  }

  // floor collision: check buildings & bridges
  const feetX = player.x;
  const feetY = player.y + player.h/2;
  let onSomething = false;
  let platformY = Infinity;

  // buildings - collision
  for (let b of buildings){
    if (feetX >= b.x - 5 && feetX <= b.x + b.w + 5){ // slightly extend edges
      const top = b.topY;
      if (feetY >= top - 40 && feetY <= top + 60 && player.vy >= -2){
        platformY = Math.min(platformY, top);
        onSomething = true;
      }
    }
  }
  
  // bridges - Calculate exact Y position on bridge
  for (let br of bridges){
    // Check if player's feet are in contact range
    if (pointOnBridge(feetX, feetY, br)){
      const dx = br.x2 - br.x1;
      const dy = br.y2 - br.y1;
      
      if (Math.abs(dx) > 0.1) {
        // Get interpolation factor (0..1) of player position along bridge
        const t = clamp((feetX - br.x1) / dx, 0, 1);
        // Calculate exact Y on bridge at this position
        const bridgeYAtX = br.y1 + dy * t;
        
        // More lenient snap condition
        if (feetY >= bridgeYAtX - 35 && feetY <= bridgeYAtX + 40) {
          platformY = Math.min(platformY, bridgeYAtX);
          onSomething = true;
        }
      } else {
        // Vertical bridge
        const bridgeY = (br.y1 + br.y2) / 2;
        platformY = Math.min(platformY, bridgeY);
        onSomething = true;
      }
    }
  }

  if (onSomething && platformY !== Infinity){
    // snap to platform if falling or barely jumping
    if (player.vy >= -2) {
      player.y = platformY - player.h/2;
      player.vy = 0;
      player.onGround = true;
    }
  } else {
    player.onGround = false;
  }

  // If player walks off right end
  if (player.x >= WORLD_WIDTH - 20){
    if (!endingTriggered) triggerEnding();
  }

  // Collect fragments if near
  for (let f of fragments){
    if (f.taken) continue;
    if (Math.abs(player.x - f.x) < 28 && Math.abs((player.y - player.h/2) - f.y) < 28){
      collectFragment(f);
    }
  }

  // light gradually decays
  light -= LIGHT_DECAY * dt;
  light = clamp(light, LIGHT_MIN, LIGHT_MAX);
  ui.fragCount.textContent = fragments.filter(x=>x.taken).length;
  ui.lightVal.textContent = Math.round(light*100);
  ui.distVal.textContent = Math.round(player.x);

  // Void messages occasionally
  if (nowMs() - lastVoidAt > VOID_INTERVAL && Math.random() < 0.004){
    lastVoidAt = nowMs();
    const msg = voidMessages[Math.floor(Math.random()*voidMessages.length)];
    showMessage(msg, 2800);
    light = clamp(light - 0.035, LIGHT_MIN, LIGHT_MAX);
  }

  // Trigger reset if falling
  if (isFalling && !endingTriggered && !isDead){
    resetToStart("He fell into the void.");
  }
}

/* ---------- Trigger ending ---------- */
function triggerEnding(){
  endingTriggered = true;
  showMessage("He kept walking. The sky softened.", 4200);
  // create long lasting soft bridge to suggest "open sky"
  bridges.push({x1: player.x + 120, y1: H/2, x2: player.x + 420, y2: H/2 - 20, life: 6000, maxLife: 6000});
}

/* ---------- Render ---------- */
function render(){
  // clear
  ctx.fillStyle = "#000";
  ctx.fillRect(0,0,W,H);

  // background parallax shapes (subtle)
  for (let i=0;i<parallaxShapes.length;i++){
    const p = parallaxShapes[i];
    const px = (p.x - camX*0.16) % WORLD_WIDTH;
    ctx.fillStyle = "rgba(255,255,255,0.02)";
    ctx.fillRect(px, H - 180 - p.yOffset, p.w, p.h);
  }

  // draw buildings
  for (let b of buildings){
    const sx = Math.round(b.x - camX);
    ctx.fillStyle = "#111";
    ctx.fillRect(sx, b.topY, b.w, b.h);
    // rooftop line
    ctx.fillStyle = "rgba(255,255,255,0.03)";
    ctx.fillRect(sx, b.topY-6, b.w, 4);
  }

  // draw fragments glowing
  for (let f of fragments){
    if (f.taken) continue;
    const sx = Math.round(f.x - camX);
    const sy = f.y;
    const g = 14 + Math.sin(f.x*0.01 + performance.now()*0.003) * 5;
    ctx.beginPath();
    ctx.fillStyle = "rgba(255,255,255,0.06)";
    ctx.ellipse(sx, sy-6, g*2.2, g*1.0, 0,0,Math.PI*2);
    ctx.fill();
    ctx.fillStyle = "#fff";
    ctx.beginPath();
    ctx.ellipse(sx, sy, f.size, f.size, 0,0,Math.PI*2);
    ctx.fill();
  }

  // draw bridges (drawn by player)
  for (let br of bridges){
    const x1 = br.x1 - camX, x2 = br.x2 - camX, y1 = br.y1, y2 = br.y2;
    // alpha based on life
    const a = clamp(br.life / br.maxLife, 0, 1);
    ctx.strokeStyle = `rgba(255,255,255,${0.9*a})`;
    ctx.lineWidth = 6;
    ctx.lineCap = 'round';
    ctx.beginPath();
    ctx.moveTo(x1, y1);
    ctx.lineTo(x2, y2);
    ctx.stroke();
    // thin brighter center
    ctx.strokeStyle = `rgba(0,0,0,${0.6*(1-a)})`;
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.moveTo(x1, y1);
    ctx.lineTo(x2, y2);
    ctx.stroke();
  }

  // draw trail echoes
  for (let i=0;i<trail.length;i++){
    const t = trail[i];
    const sx = Math.round(t.x - camX), sy = t.y;
    const alpha = clamp(t.life/140, 0, 1);
    ctx.fillStyle = `rgba(255,255,255,${alpha*0.12})`;
    ctx.beginPath();
    ctx.ellipse(sx, sy, 10 * alpha, 6 * alpha, 0,0,Math.PI*2);
    ctx.fill();
  }

  // draw player silhouette
  const px = Math.round(player.x - camX), py = Math.round(player.y);
  // body
  ctx.fillStyle = "#fff";
  ctx.fillRect(px - player.w/2, py - player.h/2, player.w, player.h);
  // head (cutout)
  ctx.beginPath();
  ctx.fillStyle = "#000";
  ctx.ellipse(px, py - player.h/2 - 6, 8, 8, 0,0,Math.PI*2);
  ctx.fill();

  // lighting mask radial (vignette) - EXPANDED VISION EVEN MORE
  const radius = 300 + Math.round(light * 1200); // increased from 200 + 800
  const mask = ctx.createRadialGradient(px, py, radius*0.04, px, py, radius);
  mask.addColorStop(0, "rgba(0,0,0,0)");
  mask.addColorStop(0.45, "rgba(0,0,0,0.15)"); // lighter at mid
  mask.addColorStop(0.75, "rgba(0,0,0,0.55)"); // gradual fade
  mask.addColorStop(1, "rgba(0,0,0,0.88)");    // lighter at edge
  ctx.fillStyle = mask;
  ctx.fillRect(0,0,W,H);

  // draw possible current draw (if drawing)
  if (isDrawing && drawStart && drawEnd){
    const sx = drawStart.x - camX, sy = drawStart.y;
    const ex = drawEnd.x - camX, ey = drawEnd.y;
    ctx.strokeStyle = "rgba(255,255,255,0.85)";
    ctx.lineWidth = 4;
    ctx.setLineDash([8,6]);
    ctx.beginPath();
    ctx.moveTo(sx, sy);
    ctx.lineTo(ex, ey);
    ctx.stroke();
    ctx.setLineDash([]);
  }

  // overlay ending fade if triggered
  if (endingTriggered){
    ctx.fillStyle = `rgba(255,255,255,${fade})`;
    ctx.fillRect(0,0,W,H);
    if (fade > 0.6){
      ctx.fillStyle = `rgba(0,0,0,${(fade-0.6)*2})`;
      ctx.font = "700 36px 'Courier New', monospace";
      ctx.textAlign = "center";
      ctx.fillText("You kept drawing. He kept walking.", W/2, H/2 - 6);
      ctx.font = "16px 'Courier New', monospace";
      ctx.fillText("A small hand unseen can change a step.", W/2, H/2 + 22);
    }
  }

  // Render minimap
  renderMinimap();
}

/* ---------- Render Minimap ---------- */
function renderMinimap(){
  // Clear minimap
  minimapCtx.fillStyle = "rgba(0,0,0,0.9)";
  minimapCtx.fillRect(0, 0, MINIMAP_W, MINIMAP_H);

  const scale = MINIMAP_W / WORLD_WIDTH;
  const heightScale = MINIMAP_H / (H - 60); // normalize building heights to minimap height

  // Draw buildings with HEIGHT profile (silhouette view)
  minimapCtx.fillStyle = "rgba(100,100,100,0.6)";
  for (let b of buildings){
    const bx = b.x * scale;
    const bw = Math.max(b.w * scale, 2); // ensure visible width
    const bh = b.h * heightScale; // scale height proportionally
    const by = MINIMAP_H - bh; // draw from bottom up
    
    // Draw building as vertical bar
    minimapCtx.fillRect(bx, by, bw, bh);
    
    // Rooftop highlight
    minimapCtx.fillStyle = "rgba(255,255,255,0.4)";
    minimapCtx.fillRect(bx, by, bw, 2);
    minimapCtx.fillStyle = "rgba(100,100,100,0.6)";
  }

  // Draw ground line
  minimapCtx.strokeStyle = "rgba(255,255,255,0.2)";
  minimapCtx.lineWidth = 1;
  minimapCtx.beginPath();
  minimapCtx.moveTo(0, MINIMAP_H - 1);
  minimapCtx.lineTo(MINIMAP_W, MINIMAP_H - 1);
  minimapCtx.stroke();

  // Draw fragments (yellow dots at their actual heights)
  for (let f of fragments){
    if (f.taken) continue;
    const fx = f.x * scale;
    // Calculate fragment Y position based on its actual Y coordinate
    const fragHeightFromBottom = (H - f.y) * heightScale;
    const fy = MINIMAP_H - fragHeightFromBottom;
    
    minimapCtx.fillStyle = "rgba(255,220,50,0.9)";
    minimapCtx.beginPath();
    minimapCtx.arc(fx, fy, 2.5, 0, Math.PI*2);
    minimapCtx.fill();
    
    // Small glow
    minimapCtx.fillStyle = "rgba(255,220,50,0.3)";
    minimapCtx.beginPath();
    minimapCtx.arc(fx, fy, 4, 0, Math.PI*2);
    minimapCtx.fill();
  }

  // Draw bridges (if any active)
  minimapCtx.strokeStyle = "rgba(255,255,255,0.5)";
  minimapCtx.lineWidth = 1.5;
  for (let br of bridges){
    const x1 = br.x1 * scale;
    const x2 = br.x2 * scale;
    const y1 = MINIMAP_H - ((H - br.y1) * heightScale);
    const y2 = MINIMAP_H - ((H - br.y2) * heightScale);
    
    const alpha = clamp(br.life / br.maxLife, 0, 1);
    minimapCtx.globalAlpha = alpha * 0.7;
    minimapCtx.beginPath();
    minimapCtx.moveTo(x1, y1);
    minimapCtx.lineTo(x2, y2);
    minimapCtx.stroke();
    minimapCtx.globalAlpha = 1;
  }

  // Draw player position (RED dot at actual height)
  const playerX = player.x * scale;
  const playerHeightFromBottom = (H - player.y) * heightScale;
  const playerY = MINIMAP_H - playerHeightFromBottom;
  
  // Player glow
  minimapCtx.fillStyle = "rgba(255,50,50,0.4)";
  minimapCtx.beginPath();
  minimapCtx.arc(playerX, playerY, 5, 0, Math.PI*2);
  minimapCtx.fill();
  
  // Player core
  minimapCtx.fillStyle = "#ff3333";
  minimapCtx.beginPath();
  minimapCtx.arc(playerX, playerY, 3, 0, Math.PI*2);
  minimapCtx.fill();

  // Draw viewport indicator (vertical line showing camera center)
  const viewCenter = (camX + W/2) * scale;
  minimapCtx.strokeStyle = "rgba(255,50,50,0.3)";
  minimapCtx.lineWidth = 1;
  minimapCtx.setLineDash([3, 3]);
  minimapCtx.beginPath();
  minimapCtx.moveTo(viewCenter, 0);
  minimapCtx.lineTo(viewCenter, MINIMAP_H);
  minimapCtx.stroke();
  minimapCtx.setLineDash([]);

  // Border
  minimapCtx.strokeStyle = "rgba(255,255,255,0.4)";
  minimapCtx.lineWidth = 1;
  minimapCtx.strokeRect(0, 0, MINIMAP_W, MINIMAP_H);
}

// ---------- Prevent default scroll for dragging space etc ----------
window.addEventListener('keydown', (e)=> { if (e.key === ' ' && e.target === document.body) e.preventDefault(); });

/* ---------- small tutorial message ---------- */
showMessage("He runs. You draw bridges between rooftops. Keep him walking.", 4600);
light = 0.45;

</script>
</body>
</html>
